# Chapter8. DOM과 브라우저 패턴

- 코어 자바스크립트가 아닌 가장 일반적인 자바스크립트 프로그램의 실행 환경인 브라우저에 특화된 여러 가지 패턴에대해 알아본다
- 브라우저 스크립팅은 사실 많은 개발자들이 자바스크립트 중에서 싫어하는 부분이기도 한데, 브라우저별로 일관성이 없는 호스트 객체와 DOM 구현들의 불편함은 클라이언트 스크립팅을 도와주는 훌륭한 패턴들을 사용한다면 이런 어려움을 덜 수 있다

## **8.1 관심사의 분리**

- 웹 애플리케이션 개발에서의 주요 관심사는 다음의 세 가지로 나누어 볼 수 있다
  - 내용
    - HTML 문서
  - 표현
    - CSS스타일: 문서가 어떻게 보여질 것인지 지정한다
  - 행동
    - 자바스크립트: 사용자 인터렉션과 문서의 동적인 변경을 처리한다
- 세 가지 관심사를 최대한 분리할수록, 좀더 광범위한 사용자 에이전트 (예를 들어 그래픽 브라우저, 텍스트만 지원하는 브라우저, 장애인을 위한 보조공학기기, 모바일 기기) 에 애플리케이션을 탑재하기가 용이해진다
- 관심사의 분리는 실무에서 다음과 같은 의미다
  1. CSS 끈 상태에서 페이지를 테스트한다. 이 상태로도 사용 가능하고 내용이 표시되며 읽을 수 있어야 한다
  2. 자바스크립트를 끈 상태에서 페이지를 테스트한다. 여전히 주 목적에 맞게 제대로 동작하고, 모든 링크가 작동하며, 홈 또한 제대로 동작하고 전송할 수 있어야 한다
  3. onclick과 같은 인라인 이벤트 핸들러 또는 인라인 style 속성은 '내용'에 속하지 않으므로 사용하지 않는다
  4. 시맨틱하고 의미에 맞는 HTML 엘리먼트를 사용한다
- '행동'에 속하는 자바스크립트는 **무간섭적**이어야 한다. 즉 자바스크립특 사용자를 방해하거나, 자바스크립트를 지원하지 않는 브라우저에서 페이지를 사용할 수 없게 만들어서는 안되며, 페이지 동작시 필수 요건이 되어서는 안된다는 뜻이다. 자바스크립트는 페이지를 향상시키기만 해야 한다
- **기능 탐지**는 브라우저간의 차이점을 우아하게 다루는 일반적인 기술 중 하나다. 사용자 에이전트를 감지해 코드를 분기하는 대신에, 사용하려는 메서드나 프로퍼티가 현재의 실행 환경에 존재하는지 확인하는 기술을 말한다. 사용자 에이전트 감지는 대체로 안티패턴이라 할 수 있다. 때로는 사용자 에이전트 감지를 쓸 수밖에 없는 경우도 있지만, 기능 탐지로 확실한 결과를 얻을 수 없거나 성능상 심각한 문제를 초래하는 경우에만 최후의 선택 사항으로 고려해야 한다

  ```javascript
  //안티패턴
  if (navigator.userAgent.indexOf("MSIE") !== 1) {
    document.attachEvent("onclick", console.log);
  }

  //더 좋은 방법
  if (document.attachEvent) {
    document.attachEvent("onclick", console.log);
  }

  //조금 더 정확한 방법
  if (typeof document.attachEvent !== "undefined") {
    document.attachEvent("onclick", console.log);
  }
  ```

- 관심사를 분리하면 개발 및 유지보수 그리고 기존의 웹애플리케이션을 업데이트하기 또한 용이해진다. 문제가 생겼을 때 어느 부분을 확인하면 되는지 알 수 있기 때문이다. 자바스크립트 오류가 발생하면, 문제를 해결하기 위해 HTML이나 CSS를 찾아볼 필요가 없다

## **8.2 DOM 스크립팅**

- 페이지의 DOM 트리를 다루는 것은 클라이언트 측 자바스크립트에서 처리하는 가장 흔한 일 중 하나다. 동시에 DOM 메서드가 브라우저간에 일관성 없이 구현되어 있기 때문에 가장 골치아픈 작업이기도 하다
- 때문에 브라우저간의 차이점을 추상화한 훌륭한 자바슬크립트 라이브러리를 사용하면 개발 속도를 크게 향상시킬 수 있다

**DOM접근**

- DOM접근은 비용이 많이 드는 작업이다
- 자바스크립트이 성능에서 DOM접근은 가장 흔한 병목 지점이다. 일반적으로 DOM은 자바스크립트 엔진과 별개로 구현되었기 때문이다. 자바스크립트 애플리케이션에서 DOM을 전혀 사용하지 않을 수도 있기 때문에, 브라우저 입장에서 보면 이런 접근 방식이 타당하다. 또한, 이러한 분리된 구현을 통해 자바스크립트 외의 언어들도 DOM작업을 할 수 있게 된다
- **핵심을 말하자면 DOM접근을 최소화해야한다**
  1. 루프 내에서 DOM 접그느을 피한다
  2. DOM 참조를 지역 변수에 할당하여 사용한다
  3. 가능하면 셀렉터 API를 사용한다
  4. HTML 콜렉션을 순회할 때 length를 캐시하여 사용한다
- 예제 1: 두 번째 루프는 코드가 길어지기 했지만 브라우저에 따라 수십에서 수백 배 빠르다

  ```javascript
  //안티패턴
  for (var i = 0; i < 100; i += 1) {
    document.getElementById("result").innerHTML += i + ",";
  }

  //지역 변수를 활용하는 개선안
  var i,
    content = "";
  for (i = 0; i < 100; i += 1) {
    content += i + ",";
  }
  document.getElementById("result").innerHTML += conetent;
  ```

- 예제 2: 지역 변수를 활용하는 첫 예제보다 한줄이 더 길고, 변수가 하나 더 필요하지만 더 좋은 코드다

  ```javascript
  //안티패턴
  var padding = document.getEmementById("result").style.padding;
  margin = document.getEmementById("result").style.margin;

  //개선안
  var style = document.getEmementById("result").style;
  padding = style.padding;
  margin = style.margin;
  ```

- 예제 3: 셀렉터 API 사용

  ```javascript
  document.querySelector("ul .sekected");
  document.querySelectorAll("#widget .class");
  ```

  - 이 메서드들은 CSS 셀렉터 문자열을 받아 그에 해당하는 DOM 모드의 목록을 반환한다. 셀렉터 메서드들은 IE8 이상을 포함한 대부분의 최신 브라우버에서 사용가능하며 다른 DOM 메서드를 사용한 선택 방식보다 항상 빠르다
  - 다중적인 자바스크립트 라이브러리들도 최신 버전에서 셀렉터 API를 활용하고 있으므로, 사용중인 라이브러리가 최신 버전인지 반드시 확인해보아야 한다
  - 자주 접근하는 엘리먼트에 id 속성을 추가하는 것도 성능 향상에 도움이 될 수 있다. document.getElementById(myid)가 노드를 찾는 가장 쉽고 빠른 방법이기 때문이다

**DOM조작**

- DOM 엘리먼트 접근 이외에도, DOM 엘리먼트를 변경 또는 제거라거나 새로운 엘리먼트를 추가하는 작업도 자주 필요하다. DOM 업데이트시 브라우저는 화면을 다시 그리고(repaint), 다시 재구조화(reflow)하는데, 이 또한 비용이 많이 드는 작업니다
- 원칙적으로 DOM 업데이트를 최소화하는게 좋다. 이를 위해서는 변경 사항들을 일괄 처리하거나, 실제 문서 트리 외부에서 변경 작업을 수행해야 한다
- 비교적 큰 서브 트리를 만들어야 한다면, 서브 트리를 완전히 생성한 다음에 문서에 추가해야한다. 이를 위해 문저 조각(document fragment)에 모든 하위 노드를 추가하는 방법을 사용할 수 있다
- 예제 1: 문서에 노드를 붙일 때 피해야할 안티패턴

  ```javascript
  //안티패턴
  //노드를 만들고 곧바로 문서에 붙인다

  var p, t;

  p = document.createElement("p");
  t = document.createTextNode("first paragraph");
  p.appendChild(t);

  document.body.appendChild(p); //곧바로 문서에 붙인다

  p = document.createElement("p");
  t = document.createTextNode("second paragraph");
  p.appendChild(t);

  document.body.appendChild(p); //곧바로 문서에 붙인다
  ```

- 개선안은 문서 조각을 생성해 외부에서 수정한 후 , 처리가 완전히 끝난 다음에 실제 DOM에 추가하는 것이다
- 편리하게도, DOM 트리에 문서 조각을 추가하면, 조각 자체는 추가되지 않고 그 내용만 추가된다. 즉 문서 조각은 별도의 부모 노드 없이도 여러 개의 노드를 감쌀 수 있는 훌륭한 방법이다 (여러 개의 p태그를 div안에 넣지 않고도 한꺼번에 처리할 수 있다)

- 예제 2: 문서조각을 사용한 개선안

  ```javascript
  var p, t, frag;

  frag = document.createDocumentFragment();

  p = document.createElement("p");
  t = document.createTextNode("first paragraph");
  p.appendChild(t);
  frag.appentChild(p);

  p = document.createElement("p");
  t = document.createTextNode("second paragraph");
  p.appendChild(t);
  frag.appentChild(p);

  document.body.appendChild(frag);
  ```

- 앞서 본 안티패턴 코드예제와 달리 p 엘리먼트를 생성할 때마다 문서를 변경하지 않고 마지막에 단 한번만 변경한다. 화면을 다시 그리고 재계산 하는 과정도 한 번만 이루어진다
- 문서 조각은 새로운 노드를 트리에 추가할 때 유용하다. 하지만 문서에 이미 존재하는 트리를 변경할 때는 변경하려는 서브 트리의 루트를 복제해서 변경한 뒤 노드와 복제한 노드를 맞바꾸면 된다
- 예제 3: 이미 존재하는 트리를 변경

  ```javascript
  var oldnode = document.getElementById("result");
  clone = oldnode.cloneNode(true);

  //복제본을 가지고 변경작업을 처리한다
  //변경이 끝나고 나면 원래의 노드와 교체한다
  oldnode.parentNode.replaceChild(clone, oldnode);
  ```

## **8.3 이벤트**

- 브라우저 스크립팅의 또 다른 영역은 click, mouseover와 같은 이벤트 처리다
- 브라우저 이벤트 처리는 최악의 일관성을 가지고 있어서 숱한 좌절의 원인이 되곤 한다. 자바스크립트 라이브러리를 사용하면 W3C를 준수하는 브라우저와 IE(9버전 미만)를 모두 지원하기 위해 두 벌로 작업하는 수고를 덜 수 있다
- 간단한 페이지에서는 라이브러리를 사용하지 않을 수도 있고, 라이브러리를 직접 만들 수도 있기 때문에 이벤트 처리를 위한 핵심 부분을 살펴보도록 하자

**이벤트 처리**

- 클릭할 때마다 카운터의 숫자를 증가시키는 버튼이 있다고 가정해보자. 인라인 onclick 속성을 추가하면 모든 브라우저에서 잘 동작하겠지만 관심사의 분리와 점진적인 개선의 원칙에 위배된다. 따라서 마크업을 건드리지 않고 항상 자바스크립트에서 이벤트 리스너를 처리해야 한다
- 예제1 : 이벤트 처리

  - 다음과 같은 마크업이 있다고 가정하다

  ```javascript
  <button id="clickme">Click me: 0</button>
  ```

  -간단하게 노드의 onclick 프로퍼티에 함수를 할당할 수도 있지만, 이 방법은 한번밖에 쓸 수 없다

  ```javascript
  var b = document.getElementByid("clickme"),
    count = 0;
  b.onclick = function () {
    count += 1;
    b.innerHTML = "Click me: " + count;
  };
  ```

  - 이 패턴으로는 하나의 클릭 이벤트에 여러 개의 함수가 실행되게 하면서 동시에 낮은 결합도를 유지하기 어렵다. 기술적으로 가능하기는 하다. onclick에 이미 함수가 할당되었는지 확읺하고, 할당되어 있다면 이미 존재하는 함수를 새로운 함수안에 추가하고 이를 onclick의 값으로 대체하면 된다
  - 그렇지만 addEventListener() 메서드를 사용하는 게 훨씬 깔끔한 해결책이다. 이 메서드는 IE8 버전까지는 존재하지 않기 때문에 IE8 버전 이하에서는 attachEvent() 메서드를 사용해야 한다

  ```javascript
  var b = document.getElementById("clickme");
  if (document.addEventListener) {
    //W3C
    b.addEventListener("click", myHandler, false);
  } else if (document.attachEvent) {
    //IE
    b.attachEvent("onclick", myHandler);
  } else {
    //최후의 수단
    b.onclick = myHandler;
  }
  ```

  - 이제 버튼을 클릭하면, myHandler() 함수가 실행될것이다. 이 함수가 버튼의 라벨에 쓰인 "Click me: 0"의 숫자를 증가시키도록 만들어보자
  - 조금더 흥미롭게, 여러 개의 버튼을 두고 모든 버튼이 myHandler() 함수 하나만 사용하게 만들것이다. 각 버튼 노드에 대한 참조와 카운터 숫자를 저장해두는 것은 비효율적이므로, 클릭할 때마다 생성되는 이벤트 객체로부터 필요한 정보를 구한다

  ```javascript
  function myHandler(e) {
    var src, parts;

    //이벤트 객체와 소스 엘리먼트를 가져온다
    e = e || window.event;
    src = e.target || t.srcElement;

    //버튼의 라벨을 변경한다
    parts = src.innerHTML.split(": ");
    parts[1] = parseInt(parts[i], 10) + 1;
    src.innerHTML = parts[0] + ": " + parts[1];

    //이벤트가 상위 노드로 전파되지 않게 한다
    if (typeof e.stopPropagation === "function") {
      e.stopPropagation();
    }
    if (typeof e.cancelBubble !== "undefined") {
      e.cancelBulle = true;
    }

    //기본 동작이 수행되지 않게 한다
    if (typeof e.preventDefault === "function") {
      e.preventDefault();
    }
    if (typeof e.returnValue !== "undefined") {
      e.returnValue = false;
    }
  }
  ```

  - 이벤트 핸들러 함수는 네 부분으로 구성되어 있다
    1. 우선 이벤트 객체를 가져온다. 이벤트 객체는 이벤트에 대한 정보와 이벤트가 발생한 엘리먼트에 대한 정보를 가지고 이싿. 이 이벤트 객체는 콜백 이벤트 핸들러에 인자로 전달되며 onclick 프로퍼티를 사용한 경우에는 전역 프로퍼티인 window.event를 통해 접근할 수 있다
    2. 두 번째 부분은 버튼의 이름을 변경하는 실제 작업을 수행한다
    3. 그 다음에는 이벤트가 상위 노드로 전파되지 않게 한다. 사실 이 예제에서는 필요하지 않지만, 일반적으로 이벤트 전파를 막지 않으면 문서의 최상단 또는 window 객체에까지 버블링되어 올라갈 수 있다. 여기서도 두 가지 방법, 즉 W3C 표준인 방법과 IE를 위한 방법을 사용한다
    4. 마지막으로, 기본 동작이 수행되지 않게 한다. 어떤 이벤트들은 지정된 기본 동작을 하는데, 필요에 따라 preventDefault() 를 사용해 이를 막을 수 있다
  - 중복 작업이 반복되기 때문에, 퍼사드 메서드로 이벤트 유틸리티를 만들어두는 게 좋다

**이벤트 위임**

- 이벤트 위임 패턴은 이벤트 버블링을 이용해서 개별 노드에 붙는 이벤트 리스너의 개수를 줄여준다. div엘리먼트 내에 열개의 버튼이 있다면, 각 버튼 엘리먼트에 리스너를 붙이는 대신 div 엘리먼트에 하나의 이벤트 리스너만 붙인다
- 예제 1: div 안에 세 개의 버튼을 가지는 예제

  ```javascript
  //사용할 마크업
  <div id="click-wrap">
    <button>Click me: 0</button>
    <button>Click me top: 0</button>
    <button>Click me three: 0</button>
  </div>
  ```

  - 각 버튼에 이벤트 리스너를 붙이는 대신 "click-wrap" div 하나의 리스너만을 붙일 것이다. 그리고 불필요한 클릭을 걸러낼 수 있도록 이전 예제의 myHandler() 함수를 약간 수정해서 사용한다
  - 다음과 같이 이벤트가 발생한 노드의 nodeName이 "button" 인지 확인하도록 myHandler()를 변경하였다

    ```javascript
    //...
    //이벤트 객체와 이벤트가 발생한 엘리먼트를 가져온다
    e = e || window.event;
    src = e.target || e.srcElement;

    if (src.nodeName.toLowerCase() !== "button") {
      return;
    }
    //...
    ```

  - 이벤트 위임에는 불필요한 이벤트를 걸러내는 코드가 약간 추가된다는 단점이 있다. 그러나 성능상의 이점과 코드의 간결성으로 인한 장점이 단점보다 훨씬 크기 때문에 적극 추천하는 패턴이다

## \*\*8.4 장시간 수행되는 스크립트

- 스크립트가 너무 오래 수행되면 때때로 브라우저가 사용자에게 스크립트를 중단시킬지 물어보는 경우가 있다. 아무리 복잡한 작업이라도 애플리케이션에서 이런 현상이 발생하는 것은 바람직 하지 않다
- 과도한 스크립트 연산을 실행하면, 브라우저 UI는 응답불가능한 상태가 되어 사용자가 아무 것도 클릭할 수 없게 된다. 이런 상태느ㅡㄴ 사용자 경험에 해가 되므로 반드시 피해야 한다
- 자바스크립트에는 스레드가 없지만, setTimeout()이나 최신 브라우저에서 지원하는 웹워커(web-worker)를 사용해 스레드를 흉내낼 수 있다

**setTimeout()**

- 많은 양의 작업을 작은 덩어리로 쪼개고 각 덩어리를 setTimeout()을 이용해 1밀리초 간격의 타입아웃을 두고 실행하는 방법으로 스레드를 시물레이션할 수 있다. 1밀리초 간견의 타입아웃 덩어리를 사용하면 전체적인 작업 진행 시간이 늘어날 수 있지만, UI를 응답가능한 상태로 유지함으로서 사용자가 더 편하게 브라우저를 제어할 수 있게 해준다

**웹워커**

- 최신의 브라우저들은 장시간 수행되는 스크립트에 대한 또 다른 해결책을 제공한다. 바로 웹워커다
- 웹워커는 브라우저 내에서 백그라운드 스레드를 제공한다. 복잡한 계산을 분리된 파일에 두고 메인 프로그램(페이지)에서 다음과 같이 호출한다
  ```javascript
  var ww = new Worker("my_web_worker.js");
  ww.onmessage = function (event) {
    document.body.innerHTML +=
      "<p>백그라운드 스레드의 메시지: " + eevent.data + "</p>";
  };
  ```
- 웹 워커 소스는 다음과 같이 간단한 산훌 연산을 1억번(1e8) 반복한다

  ```javascript
  var end = 1e8,
    tmp = 1;

  postMessage("안녕하세요");

  while (end) {
    end -= 1;
    tmp += end;
    if (end === 5e7) {
      postMessage(
        '절반 정도 진행되었습니다 현재 " tmp 값"은 ' + tmp + "입니다"
      );
    }
  }

  postMessage("작업종료");
  ```

- 웹워커는 postMessage() 메서드로 호출자(메인페이지)와 통신하며 호출자는 onmessage 이벤트를 구독해 변경 내역을 받느다
- onmassage 콜백 함수는 이벤트 객체를 인자로 받는다. 이 이벤트 객체는 data 프로퍼티를 가지는데, 웹워커가 넘겨주는 어떤 데이터든지 그 값으로 지정될 수 있다
- 이와 비슷하게 호출자는 ww.postMessage()를 사용해 웹워커에게 데이터를 전달할 수 있고, 웹워커는 onmessage 콜백을 사용해서 그 메시지를 구독할 수 있다

## **8.5 원격 스크립팅**

- 최신의 웹애플리케이션들은 현재 페이지를 다시 로드하지 않으면서 서버와 통신하기 위해 우너격 스크립팅을 자주 사용한다. 이를 통해 웹애플리케이션은 마치 데스크탑 애플리케이션처럼 빠르게 반응하게 된다

**XMLSttpRequest**

- XMLHttpRequest는 자바스크립트에서 HTTP 요청을 생성하는 특별한 객체(생성자 함수)로, 현재 대부분의 브라우저에서 사용가능하다. HTTP 요청을 만드는 과정은 세 단계로 이뤄진다
  1. XMLHttpRequest 객체를 설정한다
  2. 응답 객체의 상태가 변경될 때 알림을 받기 위한 콜백 함수를 지정한다
  3. 요청을 보낸다

**JSONP**

- 원격 요청을 생성하는 또 다른 방법은 JSONP(JSON with padding)를 사용하는 방법이다
- XHR과 달리 브라우저의 동일 도메인 정책의 제약을 받지 않는다. 따라서 서드파티 사이트에서 데이터를 로딩할 수 있으므로 보안 측면에서의 영향을 고려하여 신중하게 사용해야 한다
- XHR요청에 대한 응답이 될 수 있는 문서의 종류
  1. XML 문서(예전에 많이 사용되었다)
  2. HTML 조각(꽤 일반적으로 사용한다)
  3. JSON 데이터(가볍고 편리하다)
  4. 간단한 텍스트 파일 또는 다른 파일
- JSONP 요청에 대한 응답 데이터는 주로 JSON을 함수 호출로 감싼 형태다. 호출될 함수의 이름은 요청할 떄 함께 전달한다
- 예: JSONP 요청 URL의 일반적인 형태

  ```javascript
  http://example.org/getdata.php?callback=myHandler
  ```

  - getdata.php는 웹페이지가 될 수도 있고 스크립트가 될 수도 있다. callback 매개변수에는 응답을 처리할 자바스크립트 함수를 지정한다
  - 요청 URL은 다음과 같이 동적으로 생성된 스크립트 엘리먼트에 로드된다

  ```javascript
  var script = document.createElement("script");
  script.src = url;
  document.body.appendChild(script);
  ```

  - 서버는 JSON 데이터를 콜백 함수의 인자로 전달해 응답한다. 최종적으로 이 스크립트가 실제로 페이지에 삽인되면, 다음과 같이 콜백 함수가 호출된다

  ```javascript
  myHandler({ hello: "world" });
  ```

**프렝림과 이미지 비컨(image Beacons)**

- 원격 스크립팅을 위한 또 다른 방법으로 프레임을 사용하는 방법이 있다. 자바스크립트로 iframe을 생성하고 src에 URL을 지정하는 방식이다. 이 URL에는 데이터나 iframe외부의 부모 페이지를 업데이트 하는 함수 호출을 포함할 수 있다
- 원격 스크립팅의 가장 간단한 형태는 서버에 데이터를 보내기만 하고 응답을 필요로 하지 않는 것이다. 이런 경우에는 새로운 이미지를 만들고 이미지의 src를 서버의 스크립트로 지정하면 된다
  ```javascript
  new Image().src = "http://example.org/some/page.php";
  ```
- 이 패턴을 이미지 비컨이라 부른다. 이 패턴은 서버에 로그를 남길 목적으로 데이터를 전송할 때, 예를 들면 방문자 통계를 수집하고자 할 때 유용하다. 비컨에는 응답이 필요없기 때문에 일반적으로 서버는 1x1 픽셀 크기의 GIF 이미지를 보낸다. 이보자는 "204 No Content" HTTP 상태코드를 보내는 것이 더 좋다. 이 상태코드의 의미는 응답에 헤더만 있고 클라이언트에게 되돌려 줄 바디가 없다는 뜻이다

## **8.6 자바스크립트 배포**

- 자바스크립트를 서비스할 때 성능 측면에서 고려해야 할 사항들이 있다

**스크립트 병합**

- 빠르게 로딩되는 페이지를 구축하기 위한 첫 번째 규칙은 가능한 외부 자원의 수를 줄이는 것이다. HTTP 요청은 비용이 많이 들기 때문이다.
- 자바스크립트의 특면에서 외부 스크립트 파일들을 병합하면 페이지 로딩시간을 크게 줄일 수 있다
- 스크립트 병합은 단순히 새로운 파일을 만들고 개별 파일의 내용을 하나로 붙여넣는 작업을 뜻한다. 물론 파일을 병합하면 디버깅이 어려워지기 때문에 개발 단계가 아닌 출시 직전에 적용해야 한다
- 스크립트 병합의 단점
  1. 출시 준비에 한 단계가 추가된다. 하지만 이는 쉽게 자동화할 수 있으며 커맨드 라인에서도 수행할 수 있다. 예를 들어 리눅스/유닉스의 cat명령을 사용해 병합할 수 있다
  2. 캐싱으로 인한 이득을 보지 못할 수 있다. 여러 파일 중 파일 하나만 약간 수정하더라도 전체 캐싱을 무효화하게 된다. 따라서 큰 프로젝트인 경우 출시 일정을 두고 운영하거나 두 개의 묶음, 즉 수정 가능성이 있는 묶음과 거의 변경되지 않는 '코어' 묶음으로 구성하는 것이 좋다
  3. all_20100426.js와 같은 타임스탬프나 파일 내용의 해시를 이용하는 것처럼 묶음을 구성하기 위한 명명 규칙 또는 버전 지정 패턴을 정할 필요가 있다

**코드 압축과 gzip압축**

- 압축 프로세스를 출시를 위한 배포 프로세스에 포함시키는 것 역시 중요하다
- 사용자 관점에서 보면, 코드 내 주석은 애플리케이션이 동작하는데 아무런 상관이 없기 때문에 다운로드할 필요가 없다
- 코드 압축의 효과는 주석과 공백을 얼마나 많이 사용했는지, 그리고 어떤 압축 도구를 사용하는지에 따라서 달라질 수 있다. 하지만 평균적으로 파일 크기는 50퍼센트 정도 줄일 수 있다
- 스크립트 파일은 항상 gzip 압축을 적용해 전송해야 한다. 단 한번 gzip압축을 적용하도록 서버 설정을 변경하는 것으로 즉각적인 성능 향상을 기대할 수 있다. 서버 설정 권한을 주지않는 공유 호스팅 업체를 사용하더라도 대부분의 업테들은 최소한 .htaccess 아파치 설정 파일은 수정할 수 있게 해줄 것이다
- gzip 압축은 평균적으로 파일을 70퍼센트 정도 작게 만든다. 코드 압축과 gzip 압축을 모두 적용하면 사용자는 이전 용량의 15퍼센트 정도만을 다운로드하게 될 것이다

**Expires 헤더ㅗ**

- 파일은 브라우저 캐시에 생각보다 오래 머물지 않는다. 다시 접속하는 사용자들을 위해 Expires 헤더를 적용하여 파일들이 캐시될 확률을 높여야한다
- Expires 헤더 적용 또한 단 한번의 서버 설정으로 가능하다
- Expires 헤더 적용의 단점은 파일을 수정하고 배포하려면 파일의 이름을 바꾸어야 한다는 것이다

**CDN 사용**

- CDN(Content Delivery Nework)은 콘텐츠 전송 네트워크를 맗나다. CDN은 세계 곳곳의 서로 다른 여러 데이터 센터에 파일의 복사본들을 배치하여, 동일한 URL을 유지하면서도 더 빨리 사용자에게 전송해준다
- CDN을 사용하지 않더라도 그 이점을 무료로 누릴 수 있는 몇 가지 방법들이 있다
  1. 구글은 인기있는 오픈소스 라이브러리들을 CDN으로 제공한다. 이 라이브러리들을 무료로 링크해서 사용할 수 있다
  2. 마이크로소프트는 jQuery와 자사 Ajax 라이브러리들을 제공한다
  3. 야후는 YUI 라이브러리를 CDN으로 제공한다

## **8.7 로딩 전략**

- 웹 페이지에 스크립트를 포함시키는 방법은 간단하다. 스크립트 엘리먼트를 사용해 인라인 자바스크립트 코드를 쓰거나 src 속성에 개별 파일을 링크하면 된다

  ```javascript

  <script>
  console.log("hello world")
  </script>
  //src 속성에 링크를 지정
  <script src = "external.js"></script>
  ```

- 하지만 고성능의 웹 애플리케이션을 ㅁ낟르기 위해서는 더 많은 사항들을 고려해야하고 다양한 로딩 패턴들에 대해서 알아두어야 한다
- 개발자들이 자주 사용하는 스크립트 엘리먼트의 일반적인 속성
  1. language='JavaScript'
  - language의 속성의 값은 'JavaScript'와 같이 대문자를 포함하기도 하고 때로는 버전명과 함께 쓰이기도 한다. script 엘리먼트를 쓰는 것이 암묵적으로 자바스크립트의 사용을 의미하기 때문에 이 속성은 사용할 필요가 없다. 버전명 지정 또한 관습적인 실수이며 제대로 동작하지 않는다
  2. type="text/javascript"
  - type 속성은 HTML4와 XHTML1 표준에서는 필수 속성이지만, 반드시 있어야 하는 것은 아니다. type 값이 없더라도 브라우저는 자바스크립트로 간주하기 때문이다. HTML5에서는 type 속성이 필수가 아니다. 마크업 유효성 검사를 통과하기 위해서가 아니라면, type 속성을 사용할 이유가 전혀없다
  3. defer
  - 폭 넓게 지원되지는 않지만 defer 속성을 사용하면 외부 스크립트 파일을 다운로드하는 동안 나머지 부분의 다운로드가 차단되는 현상을 피할 수 있다

**스크립트 엘리먼트의 위치**

- 스크립트 엘리먼트는 페이지 다운로드의 진행을 차단한다. 브라우저는 여러개의 요소들을 동시에 다운로드 하는데, 외부 스크립트를 ㅏㅁㄴ나면 해당 스크립트가 다운로드 되고 파싱되어 실행될 때까지 나머지 파일의 다운로드를 중단한다
- 때문에 전체 페이지를 로드하는 데 걸리는 시간이 길어지며 특히 이런 현상이 여러 번 발행할 경우 더욱 심해진다
- 다운로드 차단 현상을 최소화하기 위해서는 스크립트 엘리먼트를 페이지의 맨 마지막 부분, 즉 닫는 바디 태그 바로 앞에 위치시켜야 한다. 이렇게 하면 다운로드가 하단될 만한 다른 리소스가 사라진다. 나머지 페이지 요소들은 이미 다운로드되어 사용자에게 보여지고 있을 것이다

**HTTP Chunked 인코딩 사용**

- HTTP 프로토콜은 소위 chunked 인코딩을 지원한다. 이를 이용해 페이지를 몇 조각으로 나누어 전송할 수 있다. 복잡한 페이지에 chuncked 인코딩을 적용하면, 서버 측 작업이 완전히 끝날 때까지 기다릴 필요 없이, 상대적으로 정적인 페이지 상단 부분을 먼저 전송하기 시작할 수 있다
- 간단한 전약 중 하나로 페이지의 나머지 부분이 만들어지는 동안 헤드 부분을 첫 번쨰 조각으로 전송하는 방법이다 있다
- 페이지 맨 마지막에 세 번째 조각을 두어 스크립트만 모아놓고 전송하는 게 가장 좋은 방법이다. 모든 페이지의 상단이 어느 정도 정적인 내용으로 구성되어 있다면, 첫 번째 조각에 본문 바디의 일부분까지 포함시킬 수도 있다
- 이 접근 방법은 점진적인 개선과 무간섭적인 자바스크립트의 원칙에도 잘 들어 맞는다. 두 번째 HTML조각까지 완료된 직후에는 마치 브라우저에서 자바스크립트를 비활성화시킨 상태처럼 페이지가 오나전히 로드되어 화면에 표시되고 사용가능해야 한다. 그러고 나서 세번째 조각이 완료되면, 자바스크립트가 페이지를 향상시키고 부가기능을 덧붙인다

**다운로드를 차단하지 않는 동적인 스크립트 엘리먼트**

- 자바스크립트는 뒤이어 오는 파일들의 다운로드를 차단한다
- 이를 방지할 수 있는 몇 가지 패턴이 있다
  1. XHR요청으로 스크립트를 로딩한 다음 응답 문자열에 eval\*()을 실행시키는 방법. 동일 도메인 제약이 따르고 그 자체로 안티패턴인 eval()을 사용해야 한다는 단점이 있다
  2. defer와 async 속성을 사용하는 방법. 일부 브라우저에서만 동작한다
  3. 스크립트 엘리먼트를 동적으로 생성하는 방법
- 마지막에 언급한 스크립트 엘리먼트를 동적으로 생성하는 방법이 가장 좋고 쓸만한 패턴이다. JSONP에서 논했던 것과 비슷하게, 새로운 스크립트 엘리먼트를 생성하고, src 속성을 지정해야 페이지에 붙인다
- 예: 다른 파일의 다운로드를 차단하지 않고 자바스크립트 파일을 비동기적으로 로드하기
  ```javascript
  var script = document.createElement("script");
  script.src = "all_20100426.js";
  document.documentElement.fistChild.appndChild(script);
  ```
- 이 페턴을 적용하여 메인 .js 파일을 로드하는 동안에는 이 파일에 의존하여 동작하는 다른 스크립트 엘리먼트를 쓸 수 없다는 단점이 있다. 비동기 방식이므로 언제 로드가 완료될지 보장할 수 없고, 뒤이어 선언된 스크립트가 아직 정의되지 않은 객체를 참조할 수 있기 때문이다
- 이 문제를 해결하려면 모든 인라인 스크립트를 바로 실행하는 대신 배열 안의 함수로 모아두어야 한다. 그러고 나서 비동기로 js파일을 받고난 뒤 버퍼 배열 안에 모아진 모든 함수를 실행한다
- 이를 위해서는 세 단계를 거쳐야 한다

  1. 모든 인라인 코드를 저장해 둘 배열을 가능한 한 페이지의 최상단에 만든다

  ```javascript
  var mynamespace = {
    inline_scripts: [],
  };
  ```

  2. 인라인 스크립트를 함수로 감싸 inline_scripts 배열에 넣는다

  ```javascipt
  //수정점
  //<script>console.log("I am inline");</script>

  //수정후
  <script>
  mynamespace.inline_scripts.push(function() {
    console.log("I am inline")
  });
  </script>
  ```

  3. 비동기로 로드된 js스크립트가 인라인 스크립트의 버퍼 배열을 순회하면서 배열 안의 모든 함수를 실행한다

  ```javascript
  var i,
    scripts = mynamespace.inline_scripts,
    mas = scripts.length;
  for (i = 0; i < max; max += 1) {
    scripts[i]();
  }
  ```

**게으른 로딩**

- 게으른 로딩은 외부 파일을 페이지의 load 이벤트 이후에 로드하는 기법을 말한다
- 대체로 큰 묶음의 코드를 다음과 같이 두 부분으로 나누는 것이 유리하다
  1. 페이지를 초기화하고 이벤트 핸들러를 UI 엘리먼트에 붙이는 핵심 코드를 첫 번째 부분으로 정한다
  2. 사용자 인터렉션이나 다른 조건들에 의해서만 필요한 코드를 두 번째 부분으로 나눈다
- 게으른 로딩의 목적은 페이지를 점진적으로 로드하고 가능한 빨리 무언가를 동작시켜 사용할 수 있게 하는 것이다. 나머지는 사용자가 페이지를 살펴보는 동안 백그라운드에서 로드한다
- 두 번째 부분을 로드하기 위해 동적 스크립트 엘리먼트를 헤드다 바디에 붙이는 방법을 사용한다
- 대부분의 애플리케이션에서 게으른 로딩이 적용되는 코드의 크리가 핵심 코드에비해 큰데, 그 이유는 흥미로운 '동작'(드래그앤드랍, XHR, 애니메이션 같은)은 핵심 코드를 초기화한 이후에만 발생하기 때문이다

**주문형 로딩**

- 게으른 로딩 패턴은 추가 자바스크립트 코드를 사용할 가능성이 높다고 가정하고 페이지 로드 후 무조건 로드한다. 조금 더 개선해 코드 일부분, 즉 정말로 필요한 부분만 로드하도록 만들수 있다
- 주문형 로딩 패턴을 적용하면 로드할 스크립트의 파일명과 이 스크립트가 로드된 후에 실행될 콜백 함수는 받을 수 있다
- 예시: 스크립트가 로드된 후에 실행될 콜백함수를 받는 require() 함수

  ```javascript
  //require 호출 예시
  require("extra.js", function () {
    functionDefinedInExtraJs();
  });

  function require(file, callback) {
    var script = document.getElementByTagName("script")[0],
      newjs = document.createElement("script");

    //IE
    newjs.onreadysratechange = function () {
      if (newjs.readyState === "loaded" || newjs.readyState === "complete") {
        newjs.onreadystatechange = null;
        callback();
      }
    };

    //그 이외의 브라우저
    newjs.onload = function () {
      callback();
    };
    newjs.src = file;
    script.parendNode.insertBefore(newjs, script);
  }
  ```

  - ID에서는 readystatechange 이벤트를 구독하고 readtState값이 'loaded' 또는 'complete'인지 확인한다. 다른 모든 브라우저는 이를 무시할 것이다
  - 파이어폭스, 사파리, 그리고 오페라에서는 onload 프로퍼티로 load 이벤트를 구독한다
  - 이 방법은 Safari 2버전에서는 동작하지 않는다. 이 브라우저도 지원해야 한다면 특정 변수가 정의되었는지를 반복적으로 확인하도록 타이머로 시간 간격을 설정해야 한다. 정의가 되었다면, 새로운 스크립트가 로드되고 실행되었다는 뜻이다

**자바스크립트 사전 로딩**

- 게으른 로딩 패턴과 주문형 로딩 패턴에서는, 현재 페이지에 필요한 스크립트를 페이지 로드 이후에 로드한다. 이 뿐만 아니라 현재 페이지에서는 필요하지 않디만 다음으로 이동하게 될 페이지에서 필요한 스크립트를 미리 로드할 수도 있다. 이 방법을 이용하면, 사용자가 두 번째 페이지에 도착했을 떄, 이미 스크립튼가 로드되어 있기 때문에 전체적으로 더 빠른 속도를 경험하게 된다
- 사전 로딩은 동적 자바스크립트가 패턴으로 간단하게 구현할 수 있다. 사지만 짧은 시간일지라도 사전 로딩된 스크립트가 파싱되고 실행되기 때문에 자바스크립트 에러를 발생할 수도 있다. 스크립트는 이미 두 번째 페이지에서 실행되고 있다고 간주하기 때문이다
- 스크립트가 파싱되거나 실행되지 않게 로드할 수도 있다. 이 방법은 CSS나 이미지 파일에도 적용할 수 있다

  ```javascript
  //IE: 이미지 비컨 패턴으로 요청을 만든다
  new Image().src = "preloadme.js";

  //IE이외: 스크립트 엘리먼트 대신 오브젝트 엘리먼트를 사용하고, data 속성 값에 로드할 스크립트의 URL을 가리키도록 지정한다
  var obj = document.createElement("object");
  obj.data = "preloadme.js";
  document.body.appendChild(obj);
  ```

- 이 패턴의 단점은 사용자 에이전트 탐지 코드를 포함한다는 것이다. 그렇지만 이 경우에는 기능 탐지로는 브라우저의 동작을 충분히 알 수 없기 땜누에 불가피한 경우메나 사용해야 한다
- 사전 로딩 패턴은 스크립트 뿐만 아니라 모든 종류의 요소들에 적용할 수 있다
