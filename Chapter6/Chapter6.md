# Chapter6. 코드 재사용 패턴

## **6.1 클래스 방식 VS 새로운 방식의 상속 패턴**

- 자바스크립트의 생성자 함수와 new 연산자 문법은 클래스를 사용하는 문법과 매우 닮아있다

  ```javascript
  //자바에서는 다음과 같이 쓸 수 있다
  Person adam = new Person()
  //자바스크립트에서는 이렇게 쓸 수 있다
  var adam = new Person()

  ```

- 문법상의 유사성 때문에 많은 개발자들이 자바스크립트를 클래스관점에서 생각하고 클래스를 전제한 상속 패턴을 반전시켜왔다. 이러한 구현 방법을 '클래스 방식'이라고 부를 수 있고, 클래스에 대해 생각할 필요가 없는 나머지 모든 패턴은 '새로운 방식'이라고 부를 수 있다

## **6.2 클래스 방식의 상속을 사용할 경우 예상되는 산출물**

- 클래스 방식의 상속을 구현할 때의 목표는 Child()라는 생성자 함수로 생성된 객체들이 다른 생성자 함수인 Parent()의 프로퍼티를 가지도록 하는 것이다
- Parent() 생성자와 Child() 생성자를 정의한 예제는 다음과 같다

  ```javascript
  //부모 생성자
  function Parent(name) {
    this.name = name || "Adam";
  }
  //생성자의 프로토타입에 기능을 추가한다
  Parent.prototype.say = function () {
    return this.name;
  };
  //아무 내용이 없는 자식 생성자
  function Child(name) {}

  //여기서 상속이 일어난다
  inherit(Child, Parent);
  ```

  - 여기서 상속을 처리하는 inherit함수는 언어에 내장되어 있지 않기 때문에 직접 구현해야 한다

## **6.3 클래스 방식의 상속 패턴 #1 - 기본패턴**

- 재사용 가능한 inherit() 함수의 첫 번째 구현 예제는 다음과 같다

  ```javascript
  function inherit(C, P) {
    C.prototype = new P();
  }
  ```

- 여기서는 prototype 프로퍼티가 함수가 아니라 객체를 가리키게 하는 것이 중요하다. 즉 프로토타입이 부몸 생성자 함수 자체가 아니라 부모 생성자 함수로 생성한 객체 인스턴스를 가리켜야 한다
- 이렇게 구현한 후에 애플리케이션에서 new Child()를 사용해 객체를 생성하면, 프로토타입을 통해 Parent() 인스턴스의 기능을 물려받게 된다

**프로토타입 체인 추적**

- 이 패턴을 사용하면 부모 객체의 프로토타입에 추가된 프로퍼티와 메서드들과 함께 , 부모 객체 자신의 프로퍼티도 모두 물려받게 된다
- 이 상속 패턴에서 프로토타입의 체인이 어떻게 동작하는지 살펴보자
  1. new Parent()를 사용해 객체를 생성하면, 블록을 하나 만든다고 생각하자. 이 블록 안에는 데이터와 함께 다른 블록에 대한 참조를 담을 수 있다
  2. 이 블록에는 name 프로퍼티에 대한 데이터가 담겨져 있다. (new Parent).say() 등의 형태로 say() 메서드에 접근을 시도하면, new Parent() 블록에는 해당 메서드가 없다
  3. 하지만 Parent() 생서자 함수의 프로토타입 프로퍼티를 가리키는 **proto** 라는 숨겨진 링크를 통해, say() 메서드를 알고 있는 Parent.prototype 에 접근할 수 있다

**패턴 #1 의 단점**

- 단점
  1. 부모 객체의 this에 추가된 객체 자신의 프로퍼티와 프로토타입 프로퍼티를 모두 물려받게 된다. 대부분의 경우 객체 자신의 프로퍼티는 특정 인스턴스에 한정되어 재사용 할 수 없기 때문에 필요가 없다
  2. 범용 inherit() 함수는 인자를 처리하지 못하는 문제도 가지고 있다. 즉 자식 생성자에 인자를 넘겨도 부모 생서앚에게 전달하지 못한다. 자식 객체가 부모 생성자에 인자를 전달하는 방법도 있겠지만, 이 방법은 자식 인스턴스를 생성할 때마다 상속을 실행해야하기 때문에, 결국 부모 객체를 계속해서 재생성하는 셈이고, 따라서 매우 비효율적이다
