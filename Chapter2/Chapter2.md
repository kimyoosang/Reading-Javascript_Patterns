# Chapter2. 기초

## **2.1 유지보수 가능한 코드 작성**

- 시간이 흐른 다음에 코드를 다시 들여다볼 때는 다음과 같은 이유로 시간이 든다
  1. 문제를 다시 학습하고 이해하는 데 걸리는 시간
  2. 이 문제를 해결하는 코드를 이해하는 데 걸리는 시간
- 코드를 이해하는데 걸니는 시간을 줄이는 것이 대단히 중요하다. 코드는 작성하는 것보다 읽는 데 더 많은 시간이 소요된다
- 이 코드가 그 때 그 자리에서는 잘 돌아갔을지 몰라도, 애플리케이션이 완성되는 과저어에서 여러가지 일이 생기면서 재검토되고 수정과 변형을 거치게 된다
  1. 버그가 발견된다
  2. 애플리케이션에 새로운 기능이 추라된다
  3. 애플리케이션이 새로운 환경에서 동작해야 한다
  4. 코드의 용도가 변경된다
  5. 코드를 처음부터 오나전히 재작성하게 되거나, 다른 구조 심지어 다른 언어로 옮기게 된다
- **유지보수 가능한 코드**란 다음과 같은 특징을 지닌다
  1. 읽기 쉽다
  2. 일관적이다
  3. 예측 가능하다
  4. 한 사람이 작성한 것 처럼 보인다
  5. 문서화되어 있다

## **2.2 전역변수 최소화**

- 전역 변수란 어떤 함수에도 속하지 않고 선언되거나, 아에 선언되지 않은 채로 사용되는 변수를 가르친다
- 모든 자바스크립트 실행 환경에는 전역 객체(global object)가 존재한다. 어떤 함수에도 속하지 않은 상태에서 this를 사용하면 전역 객체에 접근하게 된다. 전역 변수를 생성하는 것은, 이 전역 객체의 프로퍼티를 만드는 것과 같다. 편의상 브라우저에는 전역 객체에 window라는 부가적인 프로퍼티가 존재하며 전역 객체 자신을 가리킨다

**전역 변수의 문제점**

- 전역 변수의 문제점은 자바스크립트 애플리케이션이나 웹페이지 내 모든 코드 사이에서 공유된다는 점이다. 애플리케이션 내의 다른 영역에서 목적이 다른 전역 변수를 동일한 이름으로 ㅈ어의할 경우 서로 덮어쓰게 된다
- 따라서 다른 스크립트들과 한 페이지 안에서 사이좋게 공존하려면, 전역 변수를 최소한으로 사용해야 한다
- 자바스크립트 성격상, 의도하지 않았더라도 전역 변수를 만들기가 너무나 쉽다
  1. 자바스크립트에서는 변수를 선언하지 않고도 사용할 수 있다
  2. 자바스크립트에는 암묵적 전역(implied globals)라는 개념이 있기 때문이다. 즉, 선언하지 않고 사용한 변수는 자동으로 전역 객체의 프로퍼티가 되어, 명시적으로 선언된 전역 변수와 별 차이 없이 사용할 수 있다
- 변수를 미리 선언해두면 의도치 않은 전역 변수가 생성되는 일이 없기 때문에, 연쇄 할당문을 사용해도 문제가 되지 않는다

**var 선언을 빼먹었을 때의 부작용**

- 암묵적 전역 변수와 명시적으로 선언된 변수 사이에 존재하는 또 하난의 작은 차이점은 delete 연산자를 사용하여 이 변수의 정의를 취소할 수 있는지 여부다
  1. var를 사용하여 명시적으로 ㅅ너언된 전역변수는 삭제할 수 없다
  2. var를 사용하지 않고 생성한 암묵적 전역 변수는 삭제할 수 있다
- 이는 암묵적 전역 변수가 엄밀히 말하면 변수가 아니라 전역 객체의 프로퍼티라는 사실을 보여준다
- ES5 스트릭트 모드에서는 선언되지 않은 변수에 값을 할당하면 에러가 발생한다

**전역 객체에 대한 접근**

- 브라우저에서는 코드 어느 곳에서든 window 속성을 통해 전역 객체에 접근할 수 있다
- 그러나 다른 환경에서는 이 편리한 프로퍼티가 다른 이름으로 불리거나 아예 존재하지 않을 수도 있다. window라는 식별자를 직접 사용하지 않고 전역 객체에 접근하고 싶다면, 함수 유효범위 안에서 다음과 같이 정의하면 된다

```javascript
var global = (finction () {
  return this;
}());
```

- 이렇게 하면 항상 전역객체를 얻을 수 있다
- 함수를 new와 생성자를 사용해 호출하지 않고 그냥 함수로 호출한 경우, 함수 안에서 this는 항상 전역 객체를 가리키기 때문이다. ES5 스트릭트 모드에서는 이 방법이 더이상 통하지 않기 때문에, 이 모드에서 코드가 실행될 때에는 다른 패턴을 사용해야 한다
- 예를 들어 라이브러리를 개발하고 있다면, 라이브러리 코드를 즉시 실행 함수로 감싼 후, 즉시 실행 함수의 인자로 전역 유효범위를 가리키는 this를 전달하는 방법이 있다

**단일 var 패턴**

- 함수 상단에서 var 선언을 한 번만 쓰는 패턴은 유용하고 시도해 볼 만 하다. 다음과 같은 이점들이 있다
  1. 함수에서 필요로 하는 모든 지역 변수를 한군데서 찾을 수 있다
  2. 변수를 선언하기 전에 사용할 때 발생하는 로직사으이 오류를 막아준다
  3. 변수를 먼저 선언한 후에 사용해야 한다는 사실을 상기시키기 때문에 전역 변수를 최소화하는 데 도움이 된다
  4. 코드량이 줄어든다
- 단일 var패턴은 이렇게 생겼다

```javascript
function func() {
  var a = 1,
      b = 2,
      sum = a + b,
      myobject = {},
      i,
      j,
      //함수 본문...
}
```

- 함수를 선언할 때 초기 값을 주어 초기화하는 것 역시 좋은 습관이다, 문법 오류를 막을 수 있고 코드 가독성도 향상된다
- DOM(Document Object Model)참조를 다루는 것도 좋은 예다

```javascript
function ypdateElement() {
  var el = document.getElementById("result"),
    style = el.style;
  //style을 다루는 코드...
}
```

**호이스팅(hoisting): 분산된 var 선언의 문제점**

- 자바스크립트에서는 함수 내 여기저기 여러 개의 var 선언을 사용할 수 있지만, 실제로는 모두 함수 상단에서 변수가 선언된 것과 동일하게 작동한다
- 이러한 동작 방식을 **호이스팅(hoisting:끌어올리기)**라고한다. 때문에 함수 암에서 변수를 사용한 다음에 선언하면 로직상의 오류를 일으킬 수 있다
- 자바스크립트는 동일한 유효 범위안에 있는 변수는 var 선언 전에 사용해도 이미 선언된 것으로 간주한다

```javascript
myname = "global";
function func() {
  alert(myname); //undefined
  var myname = "local";
  alert(myname); //"local"
}
```

- 첫 번째 alert는 'undefined'를 출력하는데. myname이 이 함수의 지역 변수로 선언되었다고 간주하기 때문이다. 모든 변수 선언문은 함수 상단으로 끌어올려진다. 따라서 이러한 혼란을 피하기 위해서는 사용할 변수를 모두 맨 첫 줄에서 선언하는 것이 좋다
- 앞의 코드는 다음과 같이 작성한 것과 동일하게 동작한다

```javascript
myname = "global"; //전역변수
function func() {
  var myname; //이렇게 쓴 것과 동일하다 -> var myname  = undefined;
  alert(myname); //undefined
  var myname = "local";
  alert(myname); //"local"
}
```
