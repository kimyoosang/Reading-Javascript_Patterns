# Chapter2. 기초

## **2.1 유지보수 가능한 코드 작성**

- 시간이 흐른 다음에 코드를 다시 들여다볼 때는 다음과 같은 이유로 시간이 든다
  1. 문제를 다시 학습하고 이해하는 데 걸리는 시간
  2. 이 문제를 해결하는 코드를 이해하는 데 걸리는 시간
- 코드를 이해하는데 걸니는 시간을 줄이는 것이 대단히 중요하다. 코드는 작성하는 것보다 읽는 데 더 많은 시간이 소요된다
- 이 코드가 그 때 그 자리에서는 잘 돌아갔을지 몰라도, 애플리케이션이 완성되는 과저어에서 여러가지 일이 생기면서 재검토되고 수정과 변형을 거치게 된다
  1. 버그가 발견된다
  2. 애플리케이션에 새로운 기능이 추라된다
  3. 애플리케이션이 새로운 환경에서 동작해야 한다
  4. 코드의 용도가 변경된다
  5. 코드를 처음부터 오나전히 재작성하게 되거나, 다른 구조 심지어 다른 언어로 옮기게 된다
- **유지보수 가능한 코드**란 다음과 같은 특징을 지닌다
  1. 읽기 쉽다
  2. 일관적이다
  3. 예측 가능하다
  4. 한 사람이 작성한 것 처럼 보인다
  5. 문서화되어 있다

## **2.2 전역변수 최소화**

- 전역 변수란 어떤 함수에도 속하지 않고 선언되거나, 아에 선언되지 않은 채로 사용되는 변수를 가르친다
- 모든 자바스크립트 실행 환경에는 전역 객체(global object)가 존재한다. 어떤 함수에도 속하지 않은 상태에서 this를 사용하면 전역 객체에 접근하게 된다. 전역 변수를 생성하는 것은, 이 전역 객체의 프로퍼티를 만드는 것과 같다. 편의상 브라우저에는 전역 객체에 window라는 부가적인 프로퍼티가 존재하며 전역 객체 자신을 가리킨다

**전역 변수의 문제점**

- 전역 변수의 문제점은 자바스크립트 애플리케이션이나 웹페이지 내 모든 코드 사이에서 공유된다는 점이다. 애플리케이션 내의 다른 영역에서 목적이 다른 전역 변수를 동일한 이름으로 ㅈ어의할 경우 서로 덮어쓰게 된다
- 따라서 다른 스크립트들과 한 페이지 안에서 사이좋게 공존하려면, 전역 변수를 최소한으로 사용해야 한다
- 자바스크립트 성격상, 의도하지 않았더라도 전역 변수를 만들기가 너무나 쉽다
  1. 자바스크립트에서는 변수를 선언하지 않고도 사용할 수 있다
  2. 자바스크립트에는 암묵적 전역(implied globals)라는 개념이 있기 때문이다. 즉, 선언하지 않고 사용한 변수는 자동으로 전역 객체의 프로퍼티가 되어, 명시적으로 선언된 전역 변수와 별 차이 없이 사용할 수 있다
- 변수를 미리 선언해두면 의도치 않은 전역 변수가 생성되는 일이 없기 때문에, 연쇄 할당문을 사용해도 문제가 되지 않는다

**var 선언을 빼먹었을 때의 부작용**

- 암묵적 전역 변수와 명시적으로 선언된 변수 사이에 존재하는 또 하난의 작은 차이점은 delete 연산자를 사용하여 이 변수의 정의를 취소할 수 있는지 여부다
  1. var를 사용하여 명시적으로 ㅅ너언된 전역변수는 삭제할 수 없다
  2. var를 사용하지 않고 생성한 암묵적 전역 변수는 삭제할 수 있다
- 이는 암묵적 전역 변수가 엄밀히 말하면 변수가 아니라 전역 객체의 프로퍼티라는 사실을 보여준다
- ES5 스트릭트 모드에서는 선언되지 않은 변수에 값을 할당하면 에러가 발생한다

**전역 객체에 대한 접근**

- 브라우저에서는 코드 어느 곳에서든 window 속성을 통해 전역 객체에 접근할 수 있다
- 그러나 다른 환경에서는 이 편리한 프로퍼티가 다른 이름으로 불리거나 아예 존재하지 않을 수도 있다. window라는 식별자를 직접 사용하지 않고 전역 객체에 접근하고 싶다면, 함수 유효범위 안에서 다음과 같이 정의하면 된다

```javascript
var global = (finction () {
  return this;
}());
```

- 이렇게 하면 항상 전역객체를 얻을 수 있다
- 함수를 new와 생성자를 사용해 호출하지 않고 그냥 함수로 호출한 경우, 함수 안에서 this는 항상 전역 객체를 가리키기 때문이다. ES5 스트릭트 모드에서는 이 방법이 더이상 통하지 않기 때문에, 이 모드에서 코드가 실행될 때에는 다른 패턴을 사용해야 한다
- 예를 들어 라이브러리를 개발하고 있다면, 라이브러리 코드를 즉시 실행 함수로 감싼 후, 즉시 실행 함수의 인자로 전역 유효범위를 가리키는 this를 전달하는 방법이 있다

**단일 var 패턴**

- 함수 상단에서 var 선언을 한 번만 쓰는 패턴은 유용하고 시도해 볼 만 하다. 다음과 같은 이점들이 있다
  1. 함수에서 필요로 하는 모든 지역 변수를 한군데서 찾을 수 있다
  2. 변수를 선언하기 전에 사용할 때 발생하는 로직사으이 오류를 막아준다
  3. 변수를 먼저 선언한 후에 사용해야 한다는 사실을 상기시키기 때문에 전역 변수를 최소화하는 데 도움이 된다
  4. 코드량이 줄어든다
- 단일 var패턴은 이렇게 생겼다

```javascript
function func() {
  var a = 1,
      b = 2,
      sum = a + b,
      myobject = {},
      i,
      j,
      //함수 본문...
}
```

- 함수를 선언할 때 초기 값을 주어 초기화하는 것 역시 좋은 습관이다, 문법 오류를 막을 수 있고 코드 가독성도 향상된다
- DOM(Document Object Model)참조를 다루는 것도 좋은 예다

```javascript
function ypdateElement() {
  var el = document.getElementById("result"),
    style = el.style;
  //style을 다루는 코드...
}
```

**호이스팅(hoisting): 분산된 var 선언의 문제점**

- 자바스크립트에서는 함수 내 여기저기 여러 개의 var 선언을 사용할 수 있지만, 실제로는 모두 함수 상단에서 변수가 선언된 것과 동일하게 작동한다
- 이러한 동작 방식을 **호이스팅(hoisting:끌어올리기)**라고한다. 때문에 함수 암에서 변수를 사용한 다음에 선언하면 로직상의 오류를 일으킬 수 있다
- 자바스크립트는 동일한 유효 범위안에 있는 변수는 var 선언 전에 사용해도 이미 선언된 것으로 간주한다

```javascript
myname = "global";
function func() {
  alert(myname); //undefined
  var myname = "local";
  alert(myname); //"local"
}
```

- 첫 번째 alert는 'undefined'를 출력하는데. myname이 이 함수의 지역 변수로 선언되었다고 간주하기 때문이다. 모든 변수 선언문은 함수 상단으로 끌어올려진다. 따라서 이러한 혼란을 피하기 위해서는 사용할 변수를 모두 맨 첫 줄에서 선언하는 것이 좋다
- 앞의 코드는 다음과 같이 작성한 것과 동일하게 동작한다

```javascript
myname = "global"; //전역변수
function func() {
  var myname; //이렇게 쓴 것과 동일하다 -> var myname  = undefined;
  alert(myname); //undefined
  var myname = "local";
  alert(myname); //"local"
}
```

## **2.3 for 루프**

- 일반적인 for 루프 패턴은 다음과 같이 생겼다

```javascript
for (var i = 0l i < myarrray.length; i++) {
  //myarray[i]를 다루는 코드
}
```

- 이 패턴의 문제점은 루프 순회시마다 배열의 length에 접근한다는 점이다. myarray가 배열이 아니라 HTMLCollection이라면 이 때문에 코드가 느려질 수 있다
- HTMLCollection은 기반 문서(즉 HTML 페이지)에 대한 실시간 질의라는 점에서 ㅁ누제가 된다. 즉 콜렉션의 length 속성에 접근할 때마다 실제 DOM에 질의를 요청하는 것과 같으먀, DOM 접근은 일반적으로 비용이 크다
- 따라서 for 루프를 좀더 치ㅗ적화하기 위해서는 다음 예제처럼 배열의 length를 캐시해야 한다

```javascript
for (var i = 0. max = myarray.length; i < max; i++) {
  //myarray[i]를 다루는 코드
}
```

- 이렇게 하면 length 값을 한 번만 구하고, 루프를 도는 동안 이 값을 사용하게 된다. HTMLCollection를 순회할 때 length를 캐시하면, 사파리 3에서 2배, IE7에서 190배에 이르기까지 모든 브라우저에서 속도가 향상된다
- for문에는 두 가지 변형 패턴이 있다. 이 패턴들은 다음과 같은 미세 최적화를 시도한다

  1. 변수를 하나 덜 쓴다(max가 없다)
  2. 카운트를 거꾸로 하여 0으로 내려간다. 0과 비교하는 것이 배열의 length또는 0이 아닌 값과 비교하는 것보다 대개 더 빠르기 때문이다

  ```javascript
  //1번 방법
  var i, myarray = [];
  for(i = myarray.length; i--) {
    //myarray[i]를 다루는 코드
  }
  //2번 방법
  var myarray = [],
  i = array.length;
  while (i--){
    //myarray[i]를 다루는 코드
  }
  ```

- 이러한 미세 최적화는 성능이 결정적인 요소가 되는 작업에서만 차이가 두드러진다. 그리고 JSLint는 i--의 사용을 지적할 것이다

## **2.4 for-in 루프**

- for-in 루프는 배열이 아닌 객체를 순회할 때만 사용해야 한다
- 자바스크립트에서 배열은 곧 객체이기 때문에 기술적으로는 배열을 순회할 때에도 for-in 루프를 쓸 수 있지만, 권장사항은 아니다. 배열 객체에 사용자가 정의한 기능이 추가되었다면 논리적인 오류가 발생할 수 있다
- 객체의 프로퍼티를 순회할 때는 프로토타입 체인을 따라 상속되는 프로퍼티들을 걸러내기 위해 hasOwnProperty() 메서들 사용해야 한다

```javascript
var man = {
  hands: 2,
  legs: 2,
  heads: 1,
};
//코드 어딘가에서 모든 객체에 메서드 하나가 추가되었다
if (typeof Object.prototype.clone === "undefined") {
  Object.prototype.clone = function () {};
}
//1.
for (var i in man) {
  if (man.hasOwnProperty(i)) {
    console.log(i, ":", man[i]);
  }
}
//콘솔에 출력되는 결과
//hands:2
//legs:2
//heads:1

//2. 안티패턴: hasOwnProperty를 확인하지 않는 for-in 루프
for (var i in man) {
  console.log(i, ":", man[i]);
}
//콘솔에 출력되는 결과
//hands:2
//legs:2
//heads:1
//clone: function()
```

## **2.5 내장 생성자 프로토타입 확장하기 / 확장하지 않기**

- 생성자 함수의 prototype 프로퍼티를 확장하는 것은 기능을 추가하는 좋은 방법이지만 때로는 지나치게 강력할 수 있다
- Object(), Array(), Function() 과 같은 내장 생성자의 프로토타입을 확장하는 걳은 꽤 매력적이다. 그러나 이 때문에 코드의 지속성은 심각하게 저해될 수 있다. 코드가 예측에서 벗어나는 일이 많아지기 때문이다
- 따라서 내장 생성자 프로토타입을 확장하지 않는 것이 최선이다. 예외가 허용되려면 다음과 같은 조건을 모두 만족시켜야 한다
  1. 해당 기능이 ECMAScript의 향후 버전이다 자바스크립트 구현에서 일고나되게 내장 메서드로 구현될 예정이다. 예를 들어 ECMAScript 5에 기술되었으나 아직 브라우젱 내장되지 ㅇ낳은 메서드라면 추가할 수 있다. 이 경우에는 유용한 메서드를 미리 정의하는 것이라고 할 수 있다
  2. 이 프로퍼티 또는 메서드가 이미 존재하는지, 즉 이미 코드 어딘가에 구현되어 있거나, 지원 브라우저 중 일부 자바스크립트 엔진에 내장되어 있는지 확인한다
  - 이 변경사항을 명확히 문서화하고 팀 내에서 공유한다
- 위 세 가지 조건을 만족했다면 다음 패턴에 따라 프로토타입에 추가 사항을 적용해도 된다

```javascript
if (typeof Object.prototype.myMethod !== "function") {
  Object.prototype.myMethod = function () {
    // 구현...
  };
}
```

## **2.6 switch 패턴**

- 다음 패턴을 따르면 switch문의 가독성과 견고성을 향상시킬 수 있다

  1. 각 case문을 switch문에 맞추어 정렬한다
  2. 각 case문 안에서 코드를 들여쓰기 한다
  3. 각 case문을 명확하게 break;로 종료한다
  4. break문을 생략하여 통과 시키지 않는다. 그런 방법이 최선책이라는 확신이 있다면 해당 case에 반드시 기록을 남긴다. 코드를 읽는 사람에게는 오류로 보일 수 있기 때문이다
  5. 상응하는 case문이 하나도 없을 때도 정상적인 결과가 나올 수 있도록 switch문 마지막에는 default:문을 쓴다

  ```javascript
  var inspect_me = 0,
    result = "";

  switch (inspect_me) {
    case 0:
      result = "zero";
      break;
    case 1:
      result = "one":
      break;
    default:
      result = "unknown";
  }
  ```

## **2.7 암묵적 타입캐스팅 피하기**

- 자바스크립트는 변수를 비교할 때 암묵적으로 타입케스팅을 실행한다. 때문에 flase == 0 이나 "" == 0과 같은 비교가 true를 반환한다
- 암묵적 타입캐스팅으로 인한 홍동을 막기 위해서는, 항상 표현식의 값과 타입을 모두 확인하는 === 와 !== 연산자를 사용해야 한다

**eval()피하기**

- eval()은 임의의 문자열을 받아 자바스크립트 코드로 실행한다
- eval()은 보안 문제와 관련된다. 누군가 함부로 손댄 코드를 실행시키게 될 수 도 있기 때문이다. Ajax요청으로 받아온 JSON응답을 다룰 때 보안과 유효성을 보장하기 위해서는 브라우저의 내장 메서드를 사용하여 JSON 응답을 파싱하는 것이 좋다
- JSON.pqrse()를 내장 지원하지 않는 브라우저에서는 JSON.org의 라이브러리를 사용할 수 있다
- 또 setInterval()과 setTimeout()그리고 Funtion() 생성자에 문자열을 넘기는 것도 eval()을 사용하는 것과 상당히 비슷하기 때문에, 역시 사용을 자제해야 한다
- eval()을 반드시 사용해야 한다면, 그 대신에 new Funtion()의 사용을 고려해 볼 수 있다. new Function()안에서 평가되는 코드는 지역 함수의 유효범위 안에서 실행되기 때문에 코드 내에서 var로 선언된 변수들이 자동으로 전역 변수가 되지 않는다는 약간의 장점이 있다
- 자동으로 전역 변수가 되지 못하도록 막기 위해 eval() 호출을 즉시실행 함수로 감싸는 방법도 있다
- eval()은 그 자신의 바깥쪽 유효범위에 접근하고 수정을 가할 수 있는 반면, Funtion은 그럴 수 없다

## **@.8 parseint()를 통한 숫자 변환**

- parseInt()를 사용하면 문자열로부터 숫자 값을 얻을 수 있다. 이 함수는 두 번째 매개변수로 기수를 받는데, 생략하는 겅우가 많지만 그래서는 안된다. 파싱할 문자열이 0으로 시작할 경우 문제가 생길 수 있다
- 0으로 시작하는 문자열은 ECMAScript 3 에서 8진수로 다루어진다. **ES5에서는 변경되었다.** 일관성 없고 예측을 벗어나는 결과를 피하려면 항상 기수 배개변수를 지정해 주어야 한다

```javascript
var month = "06",
  year = "09";
month = parseInt(month, 10);
year = parseInt(year, 10);
```

- 문자열을 숫자로 변환하는 또 다른 방법

```javascript
+"08"; //결과값은 8이다
Number("08"); // 8
```

- 이 방법들은 대체로 parseInt()보다 빠르다. parseInt()는 단순히 변환만 하는것이 아니라 이름이 뜻하는 바대로 파싱을 하기 때문이다. 그러나 입력값으로 "08 hello"같은 값이 들어올 수 있다면 parseInt()를 사용해야 숫자를 얻을 수 있다. 다른 방법을 사용하면 NaN이 반환되면서 실패한다

## **2.9 코딩 규칙**

- 코딩 규칙을 수립하고 준수하는 것이 중요한 이유는 이를 통해 코드의 일고나성이 유지되고 예측가능해지며 읽고 이해하기가 훨씬 더 쉬워지기 때문이다
- 규칙을 수립하여 일관되게 준수하는 것 자체가 규칙의 세부 사항보다 훨씬 중요하다는 사실을 명심하라

**들여쓰기**

- 드르여쓰기 없이 코드를 읽는 건 불가능하다. 유일하게 이보다 더 나쁜 것은 일관성 없이 들여쓰기를 사용한 코드이다. 이런 경우는 규칙을 따르는 것처럼 보이지만 읽다보면 불시에 혼동이 발생할 수 있기 때문이다
- 따라서 들여쓰기 사용을 표준화하는 것이 중요하다
- **중괄호 안에 있으면 들여써라.** 즉 함수의 본문, 루프(do,while,for,for-in), if, switch문, 객체 리터럴 표기법을 사용한 객체 프로퍼티들이 여기에 해당한다

**중괄호**

- 중괄호는 생략할 수 있을 때도 항상 써야한다
- 기술적으로는 if나 for문에 명령문이 한 줄 뿐일 경우 중괄호를 생략할 수 있지만, 그런 경우에도 중괄호를 써야 한다. 이를 통해 코드에 일고나성을 유지할 수 있고 수정하기도 쉬워진다

**여는 중괄호의 위치**

- 여는 중괄호를 같은 줄에 둘지, 다음 줄에 둘지는 개발자들마다 선호가 다른 경향이 있다. 그러나 중괄호의 위치에 따라 프로그램의 동작이 달라질 수 도 있다
- 이것은 세미콜론 삽입 장치 때문인데, 함수의 반환 값이 객체 리터럴이고 이 객체의 여는 중괄호가 다음행에 올 경우 문제를 일으킬 수 있다

```javascript
function func() {
  return;
  {
    name: "Batman";
  }
}
//이 함수는 undefined를 반환한다
//위 코드는 다음과 동일하다
function func() {
  return undefined;
  //이 다음에 나오는 코드는 실행되지 않는다
  {
    name: "Batman";
  }
}
```

- 자동으로 추가된 세미콜론 때문에 이 함수는 undefined를 반환한다. 결론적으로 항상 줄광호를 쓰고, 여는 중괄호는 선행하는 명령문과 동일한 행에 두어야 한다

```javascript
function func() {
  return {
    name: "Batman";
  };
}
```

**공백**

- 공백을 활용하는 것으로도 가독성과 코드이 일관성을 향상시킬 수 있다
- 문어체 영어에서는 쉼표와 마침표 뒤에 공백을 둔다. 똑같은 규칙을 따르면 된다. 표현식을 열거할 때 쉼표를쓸 자리에 공백을 넣고, 명령문 끝에도 하나의 '생각'이 완결되었다는 의미로 공백을 넣는다
- 모든 연산자와 피연산자를 스페이스로 분리하는 것도 공백 활용의 좋은 예 중 하나다
- 함수, if-else문, 루프, 객체 리터럴의 여는 중괄호 전, 닫는 중괄호와 else 또는 while사이에도 공백을 활용하면 좋다
- 공백을 마음껏 쓰면 파일 크기가 늘어난다는 이우로 반대하는 의견도 있으나, 이 문제는 압축을 통해 해결해야 한다
