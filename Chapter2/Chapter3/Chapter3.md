# Chapter3. 리터럴과 생성자

## **3.1 객체 리터럴**

- 자바스크립트에서 '객체'리고 하면 단순히 아름-값 쌍의 해시케이블을 생각하면 된다
- 원시 테이터 타입과 객체 모두 값이 될 수 있다. 함수도 값이 될 수 있으며 이런 함수는 메서드라고 부른다
- 자바스크립트에서 생성한 객체는 언제라도 변경할 수 있으며, 내장 네이티브 객체의 프로퍼티들도 대부분 변경이 가능하다
- 빈 객체를 정의해놓고 기능을 추가해나갈수도 있다
  ```javascript
  //빈 개개체에서 시작한다
  var dog = {};
  // 프로퍼티 하나를 추가한다
  dog.name = "Benji";
  //이번에는 메서드를 추가한다
  deg.getname = finction() {
    return dog.name
  }
  ```
- 객체 리터럴 표기법을 쓰면 다음 예제처럼 생성 시점에 객체에 기능을 추가할 수 있다
  ```javascript
  var dog = {
    name: "Benji",
    getName: function () {
      return this.name;
    },
  };
  ```
  **객체 리터럴 문법**

1. 객체를 중관호로 감싼다
2. 객체 내의 프로퍼티와 세머드를 쉼표로 분리한다. 마지막 이름 값 쌍 뒤에 쉬미표가 들어가면 IE에서는 에러가 발생하므로 마지막에는 사용하지 말아야 한다
3. 프로퍼티명과 프로퍼티 값은 콜론으로 분리한다
4. 개개체를 변수에 할당할 때는 닫는 중괄호 뒤에 세미콜론을 빼먹지 않도록 하라

**생성자 함수로 객체 생성하디**

- 자바스크립트에도 자바같은 클래스 기반 객체 생성과 비슷한 문법을 가지는 생성자 함수가 존재한다
- 다음 예제는 동일한 객체를 생성하는 두 가지 방법을 보여준다
  ```javascript
  //첫 번째 방법 - 리터럴 사용
  var car = {goes:v"fat"};
  //다른 방법 - 내장 생성자 사용
  //경고: 이 방법은 안티패턴이다
  var car = new Object();
  car.goes = "far";
  ```
- 객체 리터럴 표기법의 명백한 이점은 더 짧다. 리터럴 표기법을 사용하면 유효범위 판별 작업도 발생하지 않는다. 생성자 함수를 사용했다면 지역 유효범위에 동일한 이름의 생성ㅇ자가 있을 수 있기 때문에 Object()를호출한 위치에서부터 전역 Object 생성자까지 인터프리터가 쭉 거슬러 올라가며 유효범위를 검색해야 한다

**객체 생성자의 함정**

- Object()생성자는 인자를 받을 수 있다. 인자로 전달되는 값에 따라 생성자 함수가 다른 내장 생성자에 객체 생성을 위임할 수 도 있고, 따라서 기대한 것과는 다른 객체가 반환되기도 한다
- Object() 생성자의 이 같은 동작 방식 때문에, 런타임에 결정하는 동적인 값이 생성자에 인자로 전달될 경우 예기치 않은 결과가 반환될 수 있다
- 걀론적으로 new Object()가 아니라 더 간단하고 안정적인 객체 리터럴을 사용하는 것이 좋다
