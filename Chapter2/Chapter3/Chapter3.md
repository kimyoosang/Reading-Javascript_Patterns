# Chapter3. 리터럴과 생성자

## **3.1 객체 리터럴**

- 자바스크립트에서 '객체'리고 하면 단순히 아름-값 쌍의 해시케이블을 생각하면 된다
- 원시 테이터 타입과 객체 모두 값이 될 수 있다. 함수도 값이 될 수 있으며 이런 함수는 메서드라고 부른다
- 자바스크립트에서 생성한 객체는 언제라도 변경할 수 있으며, 내장 네이티브 객체의 프로퍼티들도 대부분 변경이 가능하다
- 빈 객체를 정의해놓고 기능을 추가해나갈수도 있다
  ```javascript
  //빈 개개체에서 시작한다
  var dog = {};
  // 프로퍼티 하나를 추가한다
  dog.name = "Benji";
  //이번에는 메서드를 추가한다
  deg.getname = finction() {
    return dog.name
  }
  ```
- 객체 리터럴 표기법을 쓰면 다음 예제처럼 생성 시점에 객체에 기능을 추가할 수 있다
  ```javascript
  var dog = {
    name: "Benji",
    getName: function () {
      return this.name;
    },
  };
  ```
  **객체 리터럴 문법**

1. 객체를 중관호로 감싼다
2. 객체 내의 프로퍼티와 세머드를 쉼표로 분리한다. 마지막 이름 값 쌍 뒤에 쉬미표가 들어가면 IE에서는 에러가 발생하므로 마지막에는 사용하지 말아야 한다
3. 프로퍼티명과 프로퍼티 값은 콜론으로 분리한다
4. 개개체를 변수에 할당할 때는 닫는 중괄호 뒤에 세미콜론을 빼먹지 않도록 하라

**생성자 함수로 객체 생성하디**

- 자바스크립트에도 자바같은 클래스 기반 객체 생성과 비슷한 문법을 가지는 생성자 함수가 존재한다
- 다음 예제는 동일한 객체를 생성하는 두 가지 방법을 보여준다
  ```javascript
  //첫 번째 방법 - 리터럴 사용
  var car = {goes:v"fat"};
  //다른 방법 - 내장 생성자 사용
  //경고: 이 방법은 안티패턴이다
  var car = new Object();
  car.goes = "far";
  ```
- 객체 리터럴 표기법의 명백한 이점은 더 짧다. 리터럴 표기법을 사용하면 유효범위 판별 작업도 발생하지 않는다. 생성자 함수를 사용했다면 지역 유효범위에 동일한 이름의 생성ㅇ자가 있을 수 있기 때문에 Object()를호출한 위치에서부터 전역 Object 생성자까지 인터프리터가 쭉 거슬러 올라가며 유효범위를 검색해야 한다

**객체 생성자의 함정**

- Object()생성자는 인자를 받을 수 있다. 인자로 전달되는 값에 따라 생성자 함수가 다른 내장 생성자에 객체 생성을 위임할 수 도 있고, 따라서 기대한 것과는 다른 객체가 반환되기도 한다
- Object() 생성자의 이 같은 동작 방식 때문에, 런타임에 결정하는 동적인 값이 생성자에 인자로 전달될 경우 예기치 않은 결과가 반환될 수 있다
- 걀론적으로 new Object()가 아니라 더 간단하고 안정적인 객체 리터럴을 사용하는 것이 좋다

## **3.2 사용자 정의 생성자 함수**

- 객체 리터럴 패턴이나 생성자 함수를 쓰지 않고, 직접 생성자 함수를 만들어 객체를 생성할 수 도 있다

  ```javascript
  var Person = function (name) {
    this.name = name;
    this.say = function () {
      return "I am " + this.name;
    };
  };

  var adam = new PErson("Adam");
  adam.say()l // "I am Adam"
  ```

- new와 함께 생성자 함수를 호출하면 함수 안에서 다음과 같은 일이 일어난다
  1. 빈 객체가 생성된다. 이 객체는 this라는 변수로 참조할 수 있고, 해당 함수의 프로토타입을 상속받는다
  2. this로 참조되는 객체에 프로퍼티와 메서드가 추가된다
  3. 마지막에 다른 객체가 명시적으로 반환되지 않을 경우, this로 참조된 이 객체가 반환된다

**생성자의 반환값**

- 생성자 함수를 new와 함께 호출하면 항상 객체가 반환된다. 기본값은 this로 참조되는 객체다. 생성자 함수 내에서 아무런 프로퍼티나 메서드를 추가하지 않았다면 '빈' 객체가 반환될 것이다
- 함수 내에 return문을 쓰지 않았더라도 생성자는 암묵적으로 this를 반환한다. 그러나 반환 값이 될 객체를 따로 정할 수 도 있다

  ```javascript
  var ObjectMaker = function () {
    //생성자가 다른 객체를 대신 반환하기로 결정했기 때문에 다음의 'name'프로퍼티는 무시된다
    this.name = "This is it";

    // 새로운 객체를 생성하여 반환한다
    var that = {};
    that.name = "And this's this";
    return that;
  };

  //테스트
  var o = new Objectmaker();
  console.log(0.name); // "And that's that"
  ```

- 이와 같이 생성자에서는 어떤 객체라도 반환할 수 있다. 객체가 아닌것을 반환하려고 시도하면, 에러가 발생하진 않지만 그냥 무시되고 this에 의해 참조된 객체가 대신 반환된다

## **3.3 new를 강제하는 패턴**

- 생성자를 호출할 때 new를 빼먹으면 생성자 내부의 this가 전역 객체를 가르치게 되기 때문에 논리적인 오류가 생겨 예기치 못한 결과가 나올 수 있다
- 생성자 내부에 this.member와 같은 코드가 있을 때 이 생성자를 new 없이 호출하면, 실제로는 전역 객체에 member라는 새로운 프로퍼티가 생성된다. 이 프로퍼티는 window.member 또는 그냥 member를 통해 접근할 수 있다
- 전역 네임스페이스는 항상 깨끗하게 유지해야 하기 때문에, 이런 동작 방식은 대단히 바람직하지 않다
- ECMAScript 5에서는 이러한 동작 방식의 문제에 대한 해결책으로, 스트릭트 모드에서는 this가 전역 객체를 가리키지 않도록 했다
- ES5를 쓸 수 없는 상황이라면, 생성자 함수가 new 없이 호출되어도 항상 동일하게 동작하도록 보장하는 방법을 써야한다

  1. 명명규칙

  - 가장 간단한 대안은 명명규칙을 사용하는 것이다. 생성자 함수명의 첫글자를 대문자로 쓰고 '일반적인'함수와 메서드의 첫글자는 소문자를 사용한다

  2. that 사용

  - 명명 규칙은 올바른 동작을 권고할 뿐 강제하지는 못한다
  - this에 모든 멤버를 추가하는 대신, that에 모든 멤버를 추가한 후 that을 반환한다
  - 이 패턴의 문제는 프로토타입과의 연결고리를 잃어버리게 된다는 점이다. 즉 프로토타입에 추가한 멤버를 객체에서 사용할 수 없다

  ```javascript
  function Waffle() {
    var that = {};
    that.tastes = "yummy";
    return that;
  }
  //간단한 객체라면 that이라는 지역변수를 만들 필요도 없이 객체 리터럴을 통해 객체를 반환해도 된다
  function Waffle() {
    return {
      tastes: "yummy",
    };
  }
  ```

  3. 스스로를 호출하는 생성자

  - 앞서 설명한 패턴의 문제점을 해결하고 인스턴스 객체에서 프로토타입의 프로터피들을 사용할 수 있게 하려면, 생성자 내부에서 this가 해당 생성자의 인스턴스인지를 확인하고, 그렇지 않은 경우 new와 함께 스스로를 재호출한다

  ```javascript
  function Waffle() {
    if (!(this instanceof Waffle)) {
      return new Waffle();
    }
    this.tastes = "yummy";
  }
  Waffle.prototype.wantAnother = true;
  //호출확인
  var first = new Waffle();
  second = Waffle();

  console.log(first.tastes); // "yummy"
  console.log(second.tastes); // "yummy"

  console.log(first.wantAnother); // true
  console.log(second.wantAnother); // true
  ```

  - 인스턴스를 판별하는 또다른 범용적인 방법은 생성자 이름을 하드코딩하는 대신 arguments.callee와 비교하는 것이다
  - 이것은 모든 함수가 호출될 때, 내부적으로 arguments라는 객체가 생성되며, 이 객체가 함수에 전달된 모든 인자를 담고있다는 점을 활용한 패턴이다. arguments의 callee라는 프로퍼티는 호출된 함수를 가리킨다. arguments.callee는 ES5의 스트릭트 모드에서는 허용되지 않는다는 점에 유의하라

  ```javascript
  if (!(this instanceof arguments.callee)) {
    return new arguments.callee();
  }
  ```

  ## **3.4 배열 리터럴**

  - 자바스크립트의 배열은 내장 생성자인 Array()로도 배열을 생성할 수 있지만 리터럴 표기법도 존재하며, 객체 리터럴과 마찬가지로 배열 리터럴 표기법이 더 간단하고 장점이 많다
  - 다음은 각각 Array()생성자와 리터럴 패턴을 사용하여, 동일한 원소를 가지는 배열 두 개를 만드는 방법을 보여준다

  ```javascript
  //세 개의 원소를 가지는 배열
  //경고: 안티패턴이다
  var a = new Array("itsy", "bitsy", "spider");

  //위와 똑같은 배열
  var a = ["itsy", "bitsy", "spider"];
  ```

  **배열 리터럴 문법**

- 각 원소는 수미표로 분리하고 전에 목록을 대괄호를 감싼다
- 객체나 다른 배열 등 어떤 타입의 값이든 배열 원소로 지정할 수 있다

**배열 생성자의 특이성**

- new Array()를 멀리해야하는 또 다른 이유는 Array()생성자에 숫자 하나를 전달할 경우, 이 값은 가지지 않는 배열을 생성하기 때문이다. 즉 new Array(3)은 길이가 3이고 실제 원소값은 가지지 않는 배열을 생성한다
- 원소가 존재하지 않기 때문에 어느 원소에 접근하든 undefined 값을 얻게 된다
- new Array()에 정수가 아닌 부동소숮덤을 전달할 경우 부동소수점을 가지는 수는 배열의 길이로 유효한 값이 아니기 때문에 에러가 발생한다
- 런타임에 동적으로 배열을 생성할 경우 에러 발생을 피하려면 배열의 리터럴 표기법을 쓰는 것이 훨씬 안전하다

**배열인지 판별하는 방법**

- ECMAScript 5에서는 Array.isArray()라는 새로운 메서드가 정의되었다. 이 메서드는 인자가 배열이면 true를 반환한다
  ```javascript
  Array.isArray([]); //true
  Array.isArray({
    length: 1,
    0: 1,
    slice: function () {},
  }); //false
  ```
- 실행환경에서 이 메서드를 사용할 수 없는 경우에는 Object.prototype.toString()메서드를 호출하여 판별할 수 있다. 배열에 toString을 호출하면 "[object Array]"라는 문자열을 반환하게 되어있다. 객체일 경우에는 문자열 "[object Object]"가 반환된다

  ```javascript
  if (typeof Array.isArray === "undefined") {
    Array.isArray = function (arg) {
      return Object.prototype.toString.call(arg) === "[object Array]";
    };
  }
  ```

## **3.5 JSON**

- JSON은 자바스크립트 객체 표기법(Javascript Object Notation)의 준말로, 데이터 전송 형식의 일종이다
-
- JSON은 그저 배열과 객체 리터럴 표기법의 조합일 뿐이다
- JSON에서는 프로퍼티명을 따옴표로 감싸야 한다는 점이 객체 리터럴과의 유일한 문법적 차이다. JSON 문자열에는 함수나 정규식 리터럴을 사용할 수 없다
  ```javascript
  {"name":"value", "some":[1,2,3]}
  ```

**JSON 다루기**

- eval을 사용하여 무턱대고 JSON 문자열을 평가하면 보안 문제가 있을 수 있기 때문에 가능하면 JSON.parse()를 사용하는것이 최선책이다
  ```javascript
  //입력되는 JSON문자열
  var jstr = '{"mykey": "my value"}';
  //안티패턴
  var data = eval("(" + jstr + ")");
  //권장안
  var data = JSON.parse(jstr);
  ```
- JSON.parse() 메서드의 반대는 JSON.stringify()이다. 이 메서드는 객체 또는 배열을 인자로 받아 JSON 문자열로 직렬화한다

## **3.6 정규표현식 리터럴**

- 자바스크립트에서는 정규 표현식 역시 객체이며 정규식을 생성하는 방법은 두 가지다
  1. new RegExp() 생성자를 사용한다
  2. 정규식 리터럴을 사용한다

```javascript
//정규식 리터럴
var re = /\\/gm;
//생성자
var re = new RegExp("\\\\", "gm");
```

- 정규식 리터럴이 더 짧고, 클래스 방식의 생성자를 고민하지 않아도 되기 때문에 더 쓰기 편하다. 또 RegExp()생성자를 사용하면 따옴표나 역슬래스 등을 이스케이프해야 한다. 정규식 자체가 이미 어렵기 때문에 조금이라도 간단하게 만드는 것이 좋다. 따라서 정규식 리터럴을 고수하는 것이 최선이다

**정규 표현식 리터럴 문법**

- 정규식 리터럴 표기법은 매칭에 사용되는 정규식 패턴을 슬래시로 감싼다. 두 번째 슬래시 뒤에는 따옴표 없이 문자 형태의 변경자를 둘 수 있다
  - g: 전역매칭
  - m: 여러줄 매칭
  - i: 대소문자 구분 없이 매칭
- 그러나 매칭시킬 패턴을 미리 알 수 없고 런타임에 문자열로 만들어지는 경우에는 new RegExp()를 사용해야 한다
- 정규식 리터럴과 생성자의 또다른 차이점으로는 정규식 리터럴의 경우 파싱될 때 단 한번만 객체를 생성한다는 점을 들 수 있다
- new를 빼먹고 RegExp를 호출해도 new와 함께 호출한 것처럼 동작한다

## **3.7 원시 데이터 타입 래퍼**

- 자바스크립트에는 숫자, 문자열, 불린, null, undefined의 다섯 가지 우너시 데이터 타입이 있다. null과 undefined를 제외한 나머지 세 개는 원시 데이터 타입 래퍼라 불리는 객체를 가리고 있다. 이 래퍼 객체는 각각 내장 생성자인 Number(), String(), Boolean()을 사용하여 생성된다
- 원시 데이터 타입 그대로 써도 래퍼 객체의 메서드를 활용할 수 있다. 메서드를 호출하는 순간 내부적으로는 우너시 데이터 타입 값이 객체로 임시 변호나되어 객체처럼 동작한다

  ```javascript
  // 원시 데이터 타입 문자열을 객체로 사용한다
  var s = "hello";
  console.log(s.toUpperCase()); // "HELLO"

  // 값 자체만으로도 객체처럼 동작할 수 있다
  "monkey".slice(3, 6); // "key"
  ```

- 원시 데이터 타입 값도 언제든 객체처럼 쓸 수 있기 때문에 장황한 래퍼 생성자를 쓸 필요는 사실 별로 없다

## **3.8 에러 객체**

- 자바스크립트에는 Error(), SyntaxError(), TypeError() 등 여러 가지 에러 생성자가 내장되어 있으며 throw 문과 함께 사용된다. 이 생성자들을 통해 생성된 에러 객체들은 다음과 갍은 프로퍼티를 가진다
  1. name
  - 객체를 생성한 생성자 함수의 name프로퍼티. 범용적인 Error일 수 도 있고 rangeError와 같이 좀더 특화된 생성자일 수 도 있다
  2. message
  - 객체를 생성할 때 생성자에 전달된 문자열
- 사실 throw문은 어떤 객체와도 함께 사용할 수 있다. 즉 반드시 에러 생성자를 통해 객체를 생성해야 하는 것은 아니며 직접 정의한 객체를 던질 수 도 있다
- 에러 생성자를 new없이 일반 함수로 호출해도 new를 써서 생성자로 호출한것과 동일하게 동작하여 에러 객체가 반환된다
